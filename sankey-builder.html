<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sankey Diagram Editor | Vincent Verdet</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">
    <style>
        :root {
            --color-blueberry: #002EFF;
            --color-ocean: #0062F2;
            --color-deep-sea: #003DA5;
            --color-navy: #001478;
            --color-snow: #FFFFFF;
            --color-fog: #F0F6FF;
            --color-cloud: #D0E0F2;
            --color-cobalt: #7C9CBF;
            --color-granite: #364064;
            --color-night: #353535;
            --color-smoke: #C9D1D8;
            --color-black: #000000;
            --color-success: #30A52D;
            --color-warning: #F18100;
            --color-error: #CE1618;
            --font-primary: 'Inter', 'Arial MT', Arial, sans-serif;
            --space-xs: 8px;
            --space-sm: 16px;
            --space-md: 24px;
            --space-lg: 32px;
            --space-xl: 40px;
            --radius-sm: 3px;
            --radius-md: 6px;
            --shadow-soft: 0 3px 24px 0 rgba(0,0,0,0.1);
            --shadow-medium: 0 4px 12px 0 rgba(0,0,0,0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-primary);
            background-color: var(--color-fog);
            color: var(--color-night);
            font-size: 14px;
            line-height: 1.5;
            min-height: 100vh;
        }

        /* Header */
        .header {
            background: var(--color-snow);
            padding: var(--space-sm) var(--space-lg);
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: var(--shadow-soft);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: var(--space-md);
        }

        .logo-divider {
            width: 1px;
            height: 24px;
            background: var(--color-cloud);
        }

        .app-title {
            font-weight: 700;
            font-size: 18px;
            color: var(--color-granite);
        }

        .author-name {
            font-weight: 400;
            font-size: 14px;
            color: var(--color-cobalt);
        }

        .header-actions {
            display: flex;
            gap: var(--space-sm);
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: var(--space-xs);
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-sm);
            font-family: var(--font-primary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
            height: 36px;
        }

        .btn-primary {
            background: var(--color-blueberry);
            color: var(--color-snow);
        }

        .btn-primary:hover {
            background: var(--color-ocean);
        }

        .btn-secondary {
            background: var(--color-snow);
            color: var(--color-granite);
            border: 1px solid var(--color-cloud);
        }

        .btn-secondary:hover {
            background: var(--color-fog);
            border-color: var(--color-cobalt);
        }

        .btn-icon {
            width: 36px;
            padding: 0;
            justify-content: center;
        }

        .btn .material-icons-outlined {
            font-size: 18px;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            gap: 0;
            padding: var(--space-md);
            max-height: calc(100vh - 68px);
        }

        /* Sidebar Panel */
        .sidebar {
            background: var(--color-snow);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-soft);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 100px);
            width: 340px;
            min-width: 280px;
            max-width: 600px;
            flex-shrink: 0;
        }

        /* Resize Handle */
        .resize-handle {
            width: 16px;
            cursor: col-resize;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.2s;
            margin: 0 4px;
        }

        .resize-handle:hover,
        .resize-handle.dragging {
            background: var(--color-fog);
            border-radius: var(--radius-sm);
        }

        .resize-handle::after {
            content: '';
            width: 4px;
            height: 48px;
            background: var(--color-cloud);
            border-radius: 2px;
            transition: background 0.2s;
        }

        .resize-handle:hover::after,
        .resize-handle.dragging::after {
            background: var(--color-blueberry);
        }

        /* Canvas Area */
        .canvas-area {
            background: var(--color-snow);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-soft);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }

        .panel-header {
            padding: var(--space-sm) var(--space-md);
            border-bottom: 1px solid var(--color-cloud);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--color-snow);
        }

        .panel-title {
            font-weight: 600;
            font-size: 14px;
            color: var(--color-granite);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .panel-content {
            padding: var(--space-md);
            overflow-y: auto;
            flex: 1;
        }

        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--color-cloud);
            background: var(--color-fog);
        }

        .tab {
            padding: var(--space-sm) var(--space-md);
            font-size: 13px;
            font-weight: 500;
            color: var(--color-cobalt);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .tab:hover {
            color: var(--color-granite);
        }

        .tab.active {
            color: var(--color-blueberry);
            border-bottom-color: var(--color-blueberry);
            background: var(--color-snow);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Data Table */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .data-table th {
            text-align: left;
            padding: var(--space-xs);
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--color-cobalt);
            background: var(--color-fog);
            border-bottom: 1px solid var(--color-cloud);
        }

        .data-table td {
            padding: 6px var(--space-xs);
            border-bottom: 1px solid var(--color-cloud);
            vertical-align: middle;
        }

        .data-table tr:hover {
            background: var(--color-fog);
        }

        .data-table input[type="text"],
        .data-table input[type="number"] {
            width: 100%;
            border: 1px solid transparent;
            padding: 4px 6px;
            font-family: var(--font-primary);
            font-size: 13px;
            border-radius: var(--radius-sm);
            background: transparent;
        }

        .data-table input:hover {
            border-color: var(--color-cloud);
        }

        .data-table input:focus {
            outline: none;
            border-color: var(--color-blueberry);
            background: var(--color-snow);
        }

        .data-table input[type="number"] {
            width: 60px;
            text-align: right;
        }

        .delete-row {
            color: var(--color-cobalt);
            cursor: pointer;
            padding: 4px;
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .delete-row:hover {
            color: var(--color-error);
            background: rgba(206, 22, 24, 0.1);
        }

        .delete-row .material-icons-outlined {
            font-size: 16px;
        }

        /* Color Swatch Button */
        .color-swatch-btn {
            width: 28px;
            height: 28px;
            border-radius: var(--radius-sm);
            border: 2px solid var(--color-cloud);
            cursor: pointer;
            position: relative;
            transition: border-color 0.2s;
        }

        .color-swatch-btn:hover {
            border-color: var(--color-cobalt);
        }

        /* Color Picker Dropdown */
        .color-picker-dropdown {
            display: none;
        }

        /* Global Color Picker */
        .global-color-picker {
            position: fixed;
            z-index: 9999;
            background: var(--color-snow);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-medium);
            padding: var(--space-sm);
            width: 240px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }

        .global-color-picker.active {
            display: block;
        }

        .color-section-title {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--color-cobalt);
            margin-bottom: 6px;
            margin-top: 8px;
        }

        .color-section-title:first-child {
            margin-top: 0;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 3px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s ease;
        }

        .color-swatch:hover {
            transform: scale(1.15);
            z-index: 1;
        }

        .color-swatch.selected {
            border-color: var(--color-night);
            box-shadow: 0 0 0 2px var(--color-snow);
        }

        .color-swatch[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--color-granite);
            color: var(--color-snow);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
        }

        /* Node List */
        .node-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }

        .node-item {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            padding: var(--space-xs) var(--space-sm);
            background: var(--color-fog);
            border-radius: var(--radius-sm);
            cursor: grab;
        }

        .node-item:hover {
            background: var(--color-cloud);
        }

        .node-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .node-name {
            flex: 1;
            font-size: 13px;
        }

        .node-value {
            font-size: 12px;
            color: var(--color-cobalt);
        }

        .canvas-toolbar {
            padding: var(--space-xs) var(--space-sm);
            border-bottom: 1px solid var(--color-cloud);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            background: var(--color-fog);
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: var(--color-cloud);
            margin: 0 var(--space-xs);
        }

        .zoom-display {
            font-size: 12px;
            color: var(--color-cobalt);
            min-width: 48px;
            text-align: center;
        }

        .canvas-wrapper {
            flex: 1;
            overflow: auto;
            position: relative;
            background-color: var(--color-snow);
        }

        .canvas-wrapper.dot-pattern {
            background-image: radial-gradient(circle, var(--color-cloud) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #sankey-canvas {
            display: block;
            min-width: 100%;
            min-height: 100%;
        }

        /* SVG Styles */
        .sankey-node {
            cursor: grab;
        }

        .sankey-node:active {
            cursor: grabbing;
        }

        .sankey-node rect {
            transition: opacity 0.2s ease;
        }

        .sankey-node:hover rect {
            opacity: 0.8;
        }

        .sankey-node text {
            font-family: var(--font-primary);
            font-size: 12px;
            font-weight: 500;
            fill: var(--color-night);
            pointer-events: none;
        }

        .sankey-link {
            fill-opacity: 0.5;
            transition: fill-opacity 0.2s ease;
        }

        .sankey-link:hover {
            fill-opacity: 0.7;
            cursor: pointer;
        }

        .sankey-link.selected {
            fill-opacity: 0.8;
            stroke: var(--color-blueberry);
            stroke-width: 2;
        }

        .flow-label {
            font-family: var(--font-primary);
            text-shadow: 
                1px 1px 2px rgba(255,255,255,0.8),
                -1px -1px 2px rgba(255,255,255,0.8),
                1px -1px 2px rgba(255,255,255,0.8),
                -1px 1px 2px rgba(255,255,255,0.8);
        }

        /* Node Context Menu */
        .node-menu {
            position: fixed;
            background: var(--color-snow);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-medium);
            min-width: 180px;
            z-index: 1000;
            display: none;
            overflow: hidden;
        }

        .node-menu.active {
            display: block;
        }

        .node-menu-header {
            padding: var(--space-xs) var(--space-sm);
            background: var(--color-fog);
            border-bottom: 1px solid var(--color-cloud);
            font-weight: 600;
            font-size: 12px;
            color: var(--color-granite);
        }

        .node-menu-item {
            padding: var(--space-xs) var(--space-sm);
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            cursor: pointer;
            font-size: 13px;
            color: var(--color-night);
            transition: background 0.15s;
        }

        .node-menu-item:hover {
            background: var(--color-fog);
        }

        .node-menu-item .material-icons-outlined {
            font-size: 16px;
            color: var(--color-cobalt);
        }

        .node-menu-item.danger {
            color: var(--color-error);
        }

        .node-menu-item.danger .material-icons-outlined {
            color: var(--color-error);
        }

        .node-menu-divider {
            height: 1px;
            background: var(--color-cloud);
            margin: 4px 0;
        }

        /* Flow Quick Edit Popup */
        .flow-popup {
            position: fixed;
            background: var(--color-snow);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-medium);
            z-index: 1000;
            display: none;
            width: 260px;
        }

        .flow-popup.active {
            display: block;
        }

        .flow-popup-header {
            padding: var(--space-sm);
            border-bottom: 1px solid var(--color-cloud);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .flow-popup-title {
            font-weight: 600;
            font-size: 13px;
            color: var(--color-granite);
        }

        .flow-popup-close {
            cursor: pointer;
            color: var(--color-cobalt);
            display: flex;
            padding: 2px;
            border-radius: 3px;
        }

        .flow-popup-close:hover {
            background: var(--color-fog);
            color: var(--color-night);
        }

        .flow-popup-body {
            padding: var(--space-sm);
            overflow: hidden;
        }

        .flow-popup-row {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-bottom: var(--space-sm);
            overflow: hidden;
        }

        .flow-popup-row:last-child {
            margin-bottom: 0;
        }

        .flow-popup-label {
            font-size: 12px;
            color: var(--color-cobalt);
            min-width: 45px;
        }

        .flow-popup-input {
            flex: 1;
            min-width: 0;
            padding: 6px 8px;
            border: 1px solid var(--color-cloud);
            border-radius: var(--radius-sm);
            font-family: var(--font-primary);
            font-size: 13px;
            box-sizing: border-box;
        }

        .flow-popup-input:focus {
            outline: none;
            border-color: var(--color-blueberry);
        }

        .flow-popup-colors {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .flow-popup-color {
            width: 24px;
            height: 24px;
            border-radius: 3px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.15s;
        }

        .flow-popup-color:hover {
            transform: scale(1.15);
        }

        .flow-popup-color.selected {
            border-color: var(--color-night);
        }

        .flow-popup-footer {
            padding: var(--space-xs) var(--space-sm);
            border-top: 1px solid var(--color-cloud);
            display: flex;
            justify-content: space-between;
        }

        .flow-popup-delete {
            color: var(--color-error);
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .flow-popup-delete:hover {
            text-decoration: underline;
        }

        /* Flow Editor Panel */
        .flow-editor {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--color-snow);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-medium);
            width: 320px;
            z-index: 200;
            display: none;
        }

        .flow-editor.active {
            display: block;
        }

        .flow-editor-header {
            padding: var(--space-sm) var(--space-md);
            border-bottom: 1px solid var(--color-cloud);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .flow-editor-title {
            font-weight: 600;
            font-size: 14px;
        }

        .flow-editor-close {
            cursor: pointer;
            color: var(--color-cobalt);
            display: flex;
        }

        .flow-editor-close:hover {
            color: var(--color-night);
        }

        .flow-editor-body {
            padding: var(--space-md);
        }

        .form-group {
            margin-bottom: var(--space-sm);
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--color-cobalt);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-input {
            width: 100%;
            padding: var(--space-xs) var(--space-sm);
            border: 1px solid var(--color-cloud);
            border-radius: var(--radius-sm);
            font-family: var(--font-primary);
            font-size: 14px;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--color-blueberry);
        }

        .flow-editor-footer {
            padding: var(--space-sm) var(--space-md);
            border-top: 1px solid var(--color-cloud);
            display: flex;
            justify-content: flex-end;
            gap: var(--space-xs);
        }

        /* Checkbox Toggle */
        .toggle-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-xs) 0;
        }

        .toggle-label {
            font-size: 13px;
            color: var(--color-night);
        }

        .toggle {
            position: relative;
            width: 40px;
            height: 22px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--color-smoke);
            transition: 0.2s;
            border-radius: 22px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.2s;
            border-radius: 50%;
        }

        .toggle input:checked + .toggle-slider {
            background-color: var(--color-blueberry);
        }

        .toggle input:checked + .toggle-slider:before {
            transform: translateX(18px);
        }

        /* Background Color Picker */
        .bg-color-row {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            margin-top: var(--space-sm);
        }

        .bg-color-label {
            font-size: 13px;
            color: var(--color-night);
            flex: 1;
        }

        .bg-swatch-btn {
            width: 32px;
            height: 32px;
            border-radius: var(--radius-sm);
            border: 2px solid var(--color-cloud);
            cursor: pointer;
            position: relative;
        }

        .bg-swatch-btn:hover {
            border-color: var(--color-cobalt);
        }

        /* Overlay */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 150;
            display: none;
        }

        .overlay.active {
            display: block;
        }

        /* Add Row Button */
        .add-row-btn {
            width: 100%;
            margin-top: var(--space-sm);
            justify-content: center;
            border: 1px dashed var(--color-cloud);
            background: transparent;
            color: var(--color-cobalt);
        }

        .add-row-btn:hover {
            border-color: var(--color-blueberry);
            color: var(--color-blueberry);
            background: var(--color-fog);
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: var(--space-lg);
            right: var(--space-lg);
            padding: var(--space-sm) var(--space-md);
            background: var(--color-granite);
            color: var(--color-snow);
            border-radius: var(--radius-md);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            box-shadow: var(--shadow-medium);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 300;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.success {
            background: var(--color-success);
        }

        .toast.error {
            background: var(--color-error);
        }

        /* Help Text */
        .help-text {
            font-size: 12px;
            color: var(--color-cobalt);
            margin-top: var(--space-md);
            padding: var(--space-sm);
            background: var(--color-fog);
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--color-blueberry);
        }

        .help-text p {
            margin-bottom: 4px;
        }

        .help-text p:last-child {
            margin-bottom: 0;
        }

        /* Settings Section */
        .settings-section {
            margin-bottom: var(--space-md);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--color-cloud);
        }

        .settings-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .settings-section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--color-cobalt);
            margin-bottom: var(--space-sm);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: var(--space-xl);
            color: var(--color-cobalt);
        }

        .empty-state .material-icons-outlined {
            font-size: 48px;
            margin-bottom: var(--space-sm);
            opacity: 0.5;
        }

        .empty-state p {
            margin-bottom: var(--space-md);
        }

        /* File Input Hidden */
        .file-input-hidden {
            display: none;
        }

        /* Relative positioning for dropdowns in table */
        .color-cell {
            position: relative;
            overflow: visible;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100% !important;
                max-width: none;
                max-height: 400px;
            }

            .resize-handle {
                display: none;
            }

            .canvas-area {
                margin-top: var(--space-md);
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-left">
            <div class="app-title">Sankey Diagram Editor</div>
            <div class="logo-divider"></div>
            <div class="author-name">Vincent Verdet</div>
        </div>
        <div class="header-actions">
            <input type="file" id="import-file" class="file-input-hidden" accept=".json">
            <button class="btn btn-secondary" onclick="document.getElementById('import-file').click()">
                <span class="material-icons-outlined">upload_file</span>
                Import JSON
            </button>
            <button class="btn btn-secondary" onclick="exportToJSON()">
                <span class="material-icons-outlined">download</span>
                Export JSON
            </button>
            <button class="btn btn-primary" onclick="exportSVG()">
                <span class="material-icons-outlined">image</span>
                Export SVG
            </button>
        </div>
    </header>

    <main class="main-container">
        <aside class="sidebar">
            <div class="tabs">
                <div class="tab active" data-tab="flows">Flows</div>
                <div class="tab" data-tab="nodes">Nodes</div>
                <div class="tab" data-tab="settings">Settings</div>
            </div>

            <div class="tab-content active" id="tab-flows">
                <div class="panel-content">
                    <table class="data-table" id="flows-table">
                        <thead>
                            <tr>
                                <th>Source</th>
                                <th>Target</th>
                                <th>Value</th>
                                <th>Color</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody id="flows-tbody">
                        </tbody>
                    </table>
                    <button class="btn add-row-btn" onclick="addFlow()">
                        <span class="material-icons-outlined">add</span>
                        Add Flow
                    </button>
                    <div class="help-text">
                        <p><strong>Tip:</strong> Click flows or nodes in the diagram to edit them directly.</p>
                        <p>Drag nodes to reposition. Right-click nodes to add/remove flows.</p>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="tab-nodes">
                <div class="panel-content">
                    <table class="data-table" id="nodes-table">
                        <thead>
                            <tr>
                                <th>Node</th>
                                <th>In</th>
                                <th>Out</th>
                                <th>Color</th>
                            </tr>
                        </thead>
                        <tbody id="nodes-tbody">
                        </tbody>
                    </table>
                    <div class="help-text">
                        <p><strong>Colors:</strong> Each flow has its own color. Nodes display the color of their largest incoming flow.</p>
                        <p><strong>Edit:</strong> Click nodes in the diagram to add flows, or right-click to delete.</p>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="tab-settings">
                <div class="panel-content">
                    <div class="settings-section">
                        <div class="settings-section-title">Display Options</div>
                        <div class="toggle-group">
                            <span class="toggle-label">Show Node Values</span>
                            <label class="toggle">
                                <input type="checkbox" id="show-node-values" checked onchange="toggleNodeValues()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="toggle-group">
                            <span class="toggle-label">Show Flow Values</span>
                            <label class="toggle">
                                <input type="checkbox" id="show-flow-values" onchange="toggleFlowValues()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>

                    <div class="settings-section">
                        <div class="settings-section-title">Background</div>
                        <div class="bg-color-row">
                            <span class="bg-color-label">Background Color</span>
                            <button class="bg-swatch-btn" id="bg-color-btn" onclick="toggleBgColorPicker(event)"></button>
                        </div>
                        <div class="toggle-group" style="margin-top: var(--space-sm);">
                            <span class="toggle-label">Show Dot Pattern</span>
                            <label class="toggle">
                                <input type="checkbox" id="dot-pattern-toggle" onchange="toggleDotPattern()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>

                    <div class="settings-section">
                        <div class="settings-section-title">Diagram Size</div>
                        <div class="form-group">
                            <label class="form-label">Width</label>
                            <input type="number" class="form-input" id="diagram-width" value="900" min="400" max="2000" onchange="updateSettings()">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Height</label>
                            <input type="number" class="form-input" id="diagram-height" value="500" min="300" max="1500" onchange="updateSettings()">
                        </div>
                    </div>

                    <div class="settings-section">
                        <div class="settings-section-title">Node Settings</div>
                        <div class="form-group">
                            <label class="form-label">Node Width</label>
                            <input type="number" class="form-input" id="node-width" value="20" min="10" max="50" onchange="updateSettings()">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Node Padding</label>
                            <input type="number" class="form-input" id="node-padding" value="40" min="10" max="100" onchange="updateSettings()">
                        </div>
                    </div>
                </div>
            </div>
        </aside>

        <div class="resize-handle" id="resize-handle"></div>

        <div class="canvas-area">
            <div class="canvas-toolbar">
                <div class="toolbar-group">
                    <button class="btn btn-secondary btn-icon" onclick="zoomOut()" title="Zoom Out">
                        <span class="material-icons-outlined">remove</span>
                    </button>
                    <span class="zoom-display" id="zoom-display">100%</span>
                    <button class="btn btn-secondary btn-icon" onclick="zoomIn()" title="Zoom In">
                        <span class="material-icons-outlined">add</span>
                    </button>
                    <button class="btn btn-secondary btn-icon" onclick="resetZoom()" title="Reset Zoom">
                        <span class="material-icons-outlined">fit_screen</span>
                    </button>
                </div>
                <div class="toolbar-divider"></div>
                <div class="toolbar-group">
                    <button class="btn btn-secondary btn-icon" onclick="resetLayout()" title="Reset Node Positions">
                        <span class="material-icons-outlined">restart_alt</span>
                    </button>
                </div>
            </div>
            <div class="canvas-wrapper" id="canvas-wrapper">
                <svg id="sankey-canvas"></svg>
            </div>
        </div>
    </main>

    <!-- Node Context Menu -->
    <div class="node-menu" id="node-menu">
        <div class="node-menu-header" id="node-menu-title">Node</div>
        <div class="node-menu-item" onclick="addFlowFromNode()">
            <span class="material-icons-outlined">arrow_forward</span>
            Add flow from this node
        </div>
        <div class="node-menu-item" onclick="addFlowToNode()">
            <span class="material-icons-outlined">arrow_back</span>
            Add flow to this node
        </div>
        <div class="node-menu-divider"></div>
        <div class="node-menu-item danger" onclick="deleteNode()">
            <span class="material-icons-outlined">delete</span>
            Delete node
        </div>
    </div>

    <!-- Flow Quick Edit Popup -->
    <div class="flow-popup" id="flow-popup">
        <div class="flow-popup-header">
            <span class="flow-popup-title" id="flow-popup-title">Edit Flow</span>
            <span class="flow-popup-close" onclick="closeFlowPopup()">
                <span class="material-icons-outlined" style="font-size: 18px;">close</span>
            </span>
        </div>
        <div class="flow-popup-body">
            <div class="flow-popup-row">
                <span class="flow-popup-label">Value</span>
                <input type="number" class="flow-popup-input" id="flow-popup-value" min="1" style="width: 80px; flex: none;">
            </div>
            <div class="flow-popup-row" style="align-items: flex-start;">
                <span class="flow-popup-label" style="padding-top: 4px;">Color</span>
                <div class="flow-popup-colors" id="flow-popup-colors"></div>
            </div>
        </div>
        <div class="flow-popup-footer">
            <span class="flow-popup-delete" onclick="deleteSelectedFlow()">
                <span class="material-icons-outlined" style="font-size: 14px;">delete</span>
                Delete flow
            </span>
            <button class="btn btn-primary" style="height: 28px; font-size: 12px;" onclick="saveFlowPopup()">Save</button>
        </div>
    </div>

    <!-- Add Flow Modal -->
    <div class="overlay" id="overlay"></div>
    <div class="flow-editor" id="flow-editor">
        <div class="flow-editor-header">
            <span class="flow-editor-title" id="add-flow-title">Add Flow</span>
            <span class="flow-editor-close" onclick="closeFlowEditor()">
                <span class="material-icons-outlined">close</span>
            </span>
        </div>
        <div class="flow-editor-body">
            <div class="form-group">
                <label class="form-label">Source</label>
                <input type="text" class="form-input" id="new-flow-source">
            </div>
            <div class="form-group">
                <label class="form-label">Target</label>
                <input type="text" class="form-input" id="new-flow-target">
            </div>
            <div class="form-group">
                <label class="form-label">Value</label>
                <input type="number" class="form-input" id="new-flow-value" value="10" min="1">
            </div>
            <div class="form-group">
                <label class="form-label">Color</label>
                <div id="new-flow-colors" style="margin-top: 8px;"></div>
            </div>
        </div>
        <div class="flow-editor-footer">
            <button class="btn btn-secondary" onclick="closeFlowEditor()">Cancel</button>
            <button class="btn btn-primary" onclick="saveNewFlow()">Add Flow</button>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast">
        <span class="material-icons-outlined">check_circle</span>
        <span id="toast-message">Success</span>
    </div>

    <!-- Global Color Picker (appended to body to avoid clipping) -->
    <div class="global-color-picker" id="global-color-picker">
        <div id="global-color-picker-content"></div>
    </div>

    <script>
        // Complete Sulzer Color Palette
        const sulzerColors = {
            blues: [
                { name: 'Navy', hex: '#001478' },
                { name: 'Indigo', hex: '#001B9A' },
                { name: 'Deep Sea', hex: '#003DA5' },
                { name: 'Blueberry', hex: '#002EFF' },
                { name: 'Ocean', hex: '#0062F2' },
                { name: 'Sea', hex: '#0D6EFD' },
                { name: 'Water', hex: '#3C8BFF' },
                { name: 'Lake', hex: '#6EA8FE' },
                { name: 'Sky', hex: '#B1D1FF' },
                { name: 'Cloud', hex: '#D0E0F2' },
                { name: 'Fog', hex: '#F0F6FF' },
                { name: 'River', hex: '#0076DE' },
                { name: 'Bondi', hex: '#00C8FF' }
            ],
            neutrals: [
                { name: 'Snow', hex: '#FFFFFF' },
                { name: 'Pearl', hex: '#FAFAFC' },
                { name: 'Moon', hex: '#F0F0F0' },
                { name: 'Smoke', hex: '#C9D1D8' },
                { name: 'Metal', hex: '#BABFC7' },
                { name: 'Rain', hex: '#ABBFD5' },
                { name: 'Cobalt', hex: '#7C9CBF' },
                { name: 'Rock', hex: '#A7A7A7' },
                { name: 'Grey', hex: '#82868B' },
                { name: 'Stone', hex: '#6B7896' },
                { name: 'Iron', hex: '#585E76' },
                { name: 'Coal', hex: '#585858' },
                { name: 'Granite', hex: '#364064' },
                { name: 'Night', hex: '#353535' },
                { name: 'Black', hex: '#000000' }
            ],
            status: [
                { name: 'Forest', hex: '#30A52D' },
                { name: 'Fire', hex: '#F18100' },
                { name: 'Ruby', hex: '#CE1618' }
            ],
            secondary: [
                { name: 'Cherry', hex: '#EA5455' },
                { name: 'Chili', hex: '#FF0000' },
                { name: 'Rose', hex: '#D63384' },
                { name: 'Lotus', hex: '#D633CF' },
                { name: 'Violet', hex: '#8F0098' },
                { name: 'Lilac', hex: '#A990DD' },
                { name: 'Berry', hex: '#7367F0' },
                { name: 'Gem', hex: '#6610F2' },
                { name: 'Moss', hex: '#20C997' },
                { name: 'Grass', hex: '#5DCA5A' },
                { name: 'Lemon', hex: '#FFDA3A' },
                { name: 'Beer', hex: '#FFB443' },
                { name: 'Sun', hex: '#FF9F43' },
                { name: 'Camel', hex: '#A97D4F' },
                { name: 'Cacao', hex: '#B16E36' }
            ]
        };

        // Background colors (subset suitable for backgrounds)
        const bgColors = [
            { name: 'Snow', hex: '#FFFFFF' },
            { name: 'Pearl', hex: '#FAFAFC' },
            { name: 'Moon', hex: '#F0F0F0' },
            { name: 'Fog', hex: '#F0F6FF' },
            { name: 'Sky', hex: '#B1D1FF' },
            { name: 'Cloud', hex: '#D0E0F2' },
            { name: 'Smoke', hex: '#C9D1D8' },
            { name: 'Rain', hex: '#ABBFD5' },
            { name: 'Granite', hex: '#364064' },
            { name: 'Night', hex: '#353535' },
            { name: 'Navy', hex: '#001478' },
            { name: 'Deep Sea', hex: '#003DA5' }
        ];

        // Default flow colors (for auto-assignment)
        const defaultFlowColors = [
            '#002EFF', '#0062F2', '#003DA5', '#30A52D', '#F18100',
            '#7367F0', '#D63384', '#20C997', '#FF9F43', '#8F0098'
        ];

        // State
        let diagramData = {
            flows: [
                { source: 'Electricity', target: 'Heating', value: 25, color: '#002EFF' },
                { source: 'Electricity', target: 'Cooling', value: 15, color: '#002EFF' },
                { source: 'Electricity', target: 'Lighting', value: 10, color: '#002EFF' },
                { source: 'Gas', target: 'Heating', value: 35, color: '#F18100' },
                { source: 'Gas', target: 'Hot Water', value: 20, color: '#F18100' },
                { source: 'Heating', target: 'Building A', value: 40, color: '#30A52D' },
                { source: 'Heating', target: 'Building B', value: 20, color: '#7367F0' },
                { source: 'Cooling', target: 'Building A', value: 10, color: '#20C997' },
                { source: 'Cooling', target: 'Building B', value: 5, color: '#D63384' }
            ],
            nodePositions: {},
            settings: {
                nodeWidth: 20,
                nodePadding: 40,
                width: 900,
                height: 500,
                backgroundColor: '#FFFFFF',
                showDotPattern: false,
                showFlowValues: false,
                showNodeValues: true
            }
        };
        
        // Get node color based on its primary (largest) incoming flow, or first outgoing flow for sources
        function getNodeColor(nodeName) {
            // Check incoming flows first
            const incomingFlows = diagramData.flows.filter(f => f.target === nodeName);
            if (incomingFlows.length > 0) {
                const primaryFlow = incomingFlows.reduce((max, f) => f.value > max.value ? f : max, incomingFlows[0]);
                return primaryFlow.color;
            }
            
            // For source nodes, use color of first outgoing flow
            const outgoingFlows = diagramData.flows.filter(f => f.source === nodeName);
            if (outgoingFlows.length > 0) {
                return outgoingFlows[0].color;
            }
            
            return defaultFlowColors[0];
        }
        
        // Check if a node is a source node (no incoming flows)
        function isSourceNode(nodeName) {
            return !diagramData.flows.some(f => f.target === nodeName);
        }
        
        // Get suggested color for new flow (based on source node's outgoing flows)
        function getSuggestedFlowColor(sourceName) {
            const existingFlows = diagramData.flows.filter(f => f.source === sourceName);
            if (existingFlows.length > 0) {
                return existingFlows[0].color;
            }
            // If source has incoming flows, suggest a new color
            const usedColors = diagramData.flows.map(f => f.color);
            const availableColors = defaultFlowColors.filter(c => !usedColors.includes(c));
            return availableColors.length > 0 ? availableColors[0] : defaultFlowColors[usedColors.length % defaultFlowColors.length];
        }

        let zoom = 1;
        let selectedFlowIndex = null;
        let draggedNode = null;
        let dragOffset = { x: 0, y: 0 };
        let activeColorPicker = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupTabs();
            setupFileImport();
            setupResizeHandle();
            renderFlowsTable();
            renderDiagram();
            updateBackgroundColorBtn();
            initBgColorPicker();
            
            // Close color pickers and popups on outside click
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.color-swatch-btn') && !e.target.closest('.bg-swatch-btn') && !e.target.closest('.global-color-picker')) {
                    closeAllColorPickers();
                }
                if (!e.target.closest('.node-menu') && !e.target.closest('.sankey-node')) {
                    document.getElementById('node-menu').classList.remove('active');
                }
                if (!e.target.closest('.flow-popup') && !e.target.closest('.sankey-link')) {
                    closeFlowPopup();
                }
            });
            
            // Prevent context menu on canvas
            document.getElementById('sankey-canvas').addEventListener('contextmenu', (e) => {
                if (e.target.closest('.sankey-node')) {
                    e.preventDefault();
                }
            });
        });

        // Resize handle functionality
        function setupResizeHandle() {
            const handle = document.getElementById('resize-handle');
            const sidebar = document.querySelector('.sidebar');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                handle.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const delta = e.clientX - startX;
                const newWidth = Math.min(Math.max(startWidth + delta, 280), 600);
                sidebar.style.width = newWidth + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    handle.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }

        // Generate color picker HTML
        function generateColorPickerHTML(selectedColor, includeAll = true) {
            let html = '';
            
            if (includeAll) {
                html += `<div class="color-section-title">Primary Blues</div>
                <div class="color-grid">`;
                sulzerColors.blues.forEach(c => {
                    const isSelected = c.hex.toUpperCase() === selectedColor?.toUpperCase();
                    html += `<div class="color-swatch${isSelected ? ' selected' : ''}" 
                        style="background: ${c.hex}" 
                        data-color="${c.hex}" 
                        title="${c.name}"></div>`;
                });
                html += `</div>`;

                html += `<div class="color-section-title">Status</div>
                <div class="color-grid">`;
                sulzerColors.status.forEach(c => {
                    const isSelected = c.hex.toUpperCase() === selectedColor?.toUpperCase();
                    html += `<div class="color-swatch${isSelected ? ' selected' : ''}" 
                        style="background: ${c.hex}" 
                        data-color="${c.hex}" 
                        title="${c.name}"></div>`;
                });
                html += `</div>`;

                html += `<div class="color-section-title">Secondary</div>
                <div class="color-grid">`;
                sulzerColors.secondary.forEach(c => {
                    const isSelected = c.hex.toUpperCase() === selectedColor?.toUpperCase();
                    html += `<div class="color-swatch${isSelected ? ' selected' : ''}" 
                        style="background: ${c.hex}" 
                        data-color="${c.hex}" 
                        title="${c.name}"></div>`;
                });
                html += `</div>`;

                html += `<div class="color-section-title">Neutrals</div>
                <div class="color-grid">`;
                sulzerColors.neutrals.forEach(c => {
                    const isSelected = c.hex.toUpperCase() === selectedColor?.toUpperCase();
                    html += `<div class="color-swatch${isSelected ? ' selected' : ''}" 
                        style="background: ${c.hex}; ${c.hex === '#FFFFFF' ? 'border: 1px solid #D0E0F2;' : ''}" 
                        data-color="${c.hex}" 
                        title="${c.name}"></div>`;
                });
                html += `</div>`;
            } else {
                // Background colors only
                html += `<div class="color-grid">`;
                bgColors.forEach(c => {
                    const isSelected = c.hex.toUpperCase() === selectedColor?.toUpperCase();
                    html += `<div class="color-swatch${isSelected ? ' selected' : ''}" 
                        style="background: ${c.hex}; ${c.hex === '#FFFFFF' ? 'border: 1px solid #D0E0F2;' : ''}" 
                        data-color="${c.hex}" 
                        title="${c.name}"></div>`;
                });
                html += `</div>`;
            }
            
            return html;
        }

        // Initialize background color picker
        function initBgColorPicker() {
            // Color picker is now handled by global picker in toggleBgColorPicker
        }

        // Update background color button
        function updateBackgroundColorBtn() {
            const btn = document.getElementById('bg-color-btn');
            btn.style.backgroundColor = diagramData.settings.backgroundColor;
        }

        // Toggle background color picker
        function toggleBgColorPicker(event) {
            event.stopPropagation();
            const picker = document.getElementById('global-color-picker');
            const content = document.getElementById('global-color-picker-content');
            const isActive = picker.classList.contains('active');
            closeAllColorPickers();
            
            if (!isActive) {
                const btn = event.currentTarget;
                const rect = btn.getBoundingClientRect();
                
                // Generate background color options
                content.innerHTML = generateColorPickerHTML(diagramData.settings.backgroundColor, false);
                content.querySelectorAll('.color-swatch').forEach(swatch => {
                    swatch.addEventListener('click', (e) => {
                        e.stopPropagation();
                        diagramData.settings.backgroundColor = swatch.dataset.color;
                        updateBackgroundColorBtn();
                        applyBackground();
                        closeAllColorPickers();
                    });
                });
                
                // Position the dropdown
                picker.style.top = rect.bottom + 4 + 'px';
                picker.style.left = Math.min(rect.left, window.innerWidth - 250) + 'px';
                
                picker.classList.add('active');
            }
        }

        // Apply background
        function applyBackground() {
            const wrapper = document.getElementById('canvas-wrapper');
            wrapper.style.backgroundColor = diagramData.settings.backgroundColor;
            
            // Update dot pattern color based on background brightness
            const isDark = isColorDark(diagramData.settings.backgroundColor);
            if (diagramData.settings.showDotPattern) {
                const dotColor = isDark ? 'rgba(255,255,255,0.2)' : '#D0E0F2';
                wrapper.style.backgroundImage = `radial-gradient(circle, ${dotColor} 1px, transparent 1px)`;
                wrapper.style.backgroundSize = '20px 20px';
            }
            
            // Re-render diagram to update text colors
            renderDiagram();
        }

        // Check if color is dark
        function isColorDark(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness < 128;
        }

        // Toggle dot pattern
        function toggleDotPattern() {
            const toggle = document.getElementById('dot-pattern-toggle');
            diagramData.settings.showDotPattern = toggle.checked;
            const wrapper = document.getElementById('canvas-wrapper');
            
            if (toggle.checked) {
                const isDark = isColorDark(diagramData.settings.backgroundColor);
                const dotColor = isDark ? 'rgba(255,255,255,0.2)' : '#D0E0F2';
                wrapper.style.backgroundImage = `radial-gradient(circle, ${dotColor} 1px, transparent 1px)`;
                wrapper.style.backgroundSize = '20px 20px';
            } else {
                wrapper.style.backgroundImage = 'none';
            }
        }

        // Close all color pickers
        function closeAllColorPickers() {
            document.getElementById('global-color-picker').classList.remove('active');
        }

        // Tab functionality
        function setupTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(`tab-${tab.dataset.tab}`).classList.add('active');
                });
            });
        }

        // File Import
        function setupFileImport() {
            document.getElementById('import-file').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const imported = JSON.parse(event.target.result);
                            if (imported.flows && Array.isArray(imported.flows)) {
                                // Ensure all flows have colors
                                const flows = imported.flows.map((f, i) => ({
                                    ...f,
                                    color: f.color || defaultFlowColors[i % defaultFlowColors.length]
                                }));
                                
                                diagramData = {
                                    flows,
                                    nodePositions: imported.nodePositions || {},
                                    settings: { 
                                        nodeWidth: 20,
                                        nodePadding: 40,
                                        width: 900,
                                        height: 500,
                                        backgroundColor: '#FFFFFF',
                                        showDotPattern: false,
                                        showFlowValues: false,
                                        showNodeValues: true,
                                        ...imported.settings 
                                    }
                                };
                                updateSettingsUI();
                                renderFlowsTable();
                                renderDiagram();
                                updateBackgroundColorBtn();
                                applyBackground();
                                document.getElementById('dot-pattern-toggle').checked = diagramData.settings.showDotPattern;
                                document.getElementById('show-node-values').checked = diagramData.settings.showNodeValues;
                                document.getElementById('show-flow-values').checked = diagramData.settings.showFlowValues;
                                if (diagramData.settings.showDotPattern) {
                                    toggleDotPattern();
                                }
                                showToast('Diagram imported successfully', 'success');
                            } else {
                                showToast('Invalid file format', 'error');
                            }
                        } catch (err) {
                            showToast('Error reading file', 'error');
                        }
                    };
                    reader.readAsText(file);
                }
                e.target.value = '';
            });
        }

        // Update settings UI
        function updateSettingsUI() {
            document.getElementById('node-width').value = diagramData.settings.nodeWidth;
            document.getElementById('node-padding').value = diagramData.settings.nodePadding;
            document.getElementById('diagram-width').value = diagramData.settings.width;
            document.getElementById('diagram-height').value = diagramData.settings.height;
        }

        // Render flows table
        function renderFlowsTable() {
            const tbody = document.getElementById('flows-tbody');
            tbody.innerHTML = diagramData.flows.map((flow, index) => `
                <tr data-index="${index}">
                    <td><input type="text" value="${flow.source}" onchange="updateFlow(${index}, 'source', this.value)"></td>
                    <td><input type="text" value="${flow.target}" onchange="updateFlow(${index}, 'target', this.value)"></td>
                    <td><input type="number" value="${flow.value}" min="1" onchange="updateFlow(${index}, 'value', parseFloat(this.value))"></td>
                    <td class="color-cell">
                        <button class="color-swatch-btn" style="background: ${flow.color}" onclick="openFlowColorPicker(event, ${index})"></button>
                    </td>
                    <td><span class="delete-row" onclick="deleteFlow(${index})"><span class="material-icons-outlined">delete</span></span></td>
                </tr>
            `).join('');
        }
        
        // Open flow color picker in table
        function openFlowColorPicker(event, index) {
            event.stopPropagation();
            closeAllColorPickers();
            closeAllPopups();
            
            const picker = document.getElementById('global-color-picker');
            const content = document.getElementById('global-color-picker-content');
            const flow = diagramData.flows[index];
            const btn = event.currentTarget;
            const rect = btn.getBoundingClientRect();
            
            content.innerHTML = generateColorPickerHTML(flow.color, true);
            
            // Position the dropdown
            const pickerHeight = 400;
            const spaceBelow = window.innerHeight - rect.bottom;
            const spaceAbove = rect.top;
            
            if (spaceBelow >= pickerHeight || spaceBelow >= spaceAbove) {
                picker.style.top = rect.bottom + 4 + 'px';
            } else {
                picker.style.top = Math.max(8, rect.top - Math.min(pickerHeight, spaceAbove) - 4) + 'px';
            }
            picker.style.left = Math.min(rect.left, window.innerWidth - 250) + 'px';
            
            picker.classList.add('active');
            
            content.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.addEventListener('click', (e) => {
                    e.stopPropagation();
                    updateFlow(index, 'color', swatch.dataset.color);
                    closeAllColorPickers();
                    renderFlowsTable();
                });
            });
        }
        
        // Render nodes table (simplified - just shows node info)
        function renderNodesTable(nodes) {
            const tbody = document.getElementById('nodes-tbody');
            if (!nodes || nodes.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--color-cobalt);">No nodes yet</td></tr>';
                return;
            }
            
            tbody.innerHTML = nodes.map((node) => {
                const color = getNodeColor(node.name);
                const inValue = node.targetLinks ? node.targetLinks.reduce((sum, l) => sum + l.value, 0) : 0;
                const outValue = node.sourceLinks ? node.sourceLinks.reduce((sum, l) => sum + l.value, 0) : 0;
                const isSource = isSourceNode(node.name);
                return `
                <tr>
                    <td>${node.name}${isSource ? ' <span style="color: var(--color-blueberry); font-size: 10px; font-weight: 600;"></span>' : ''}</td>
                    <td style="text-align: right; color: ${inValue ? 'inherit' : 'var(--color-cobalt)'};">${inValue || ''}</td>
                    <td style="text-align: right; color: ${outValue ? 'inherit' : 'var(--color-cobalt)'};">${outValue || ''}</td>
                    <td>
                        <div style="width: 20px; height: 20px; background: ${color}; border-radius: 3px; border: 1px solid var(--color-cloud);"></div>
                    </td>
                </tr>
            `}).join('');
        }

        // Update flow
        function updateFlow(index, field, value) {
            diagramData.flows[index][field] = value;
            renderDiagram();
        }

        // Add flow (from sidebar button)
        function addFlow() {
            openAddFlowModal('', '');
        }

        // Delete flow
        function deleteFlow(index) {
            diagramData.flows.splice(index, 1);
            renderFlowsTable();
            renderDiagram();
        }

        // Get unique nodes
        function getUniqueNodes() {
            const nodeSet = new Set();
            diagramData.flows.forEach(f => {
                nodeSet.add(f.source);
                nodeSet.add(f.target);
            });
            return Array.from(nodeSet);
        }

        // Calculate Sankey layout
        function calculateLayout() {
            const { nodeWidth, nodePadding, width, height } = diagramData.settings;
            const margin = { top: 20, right: 120, bottom: 20, left: 120 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;

            // Build node graph
            const nodeMap = new Map();
            const links = [];

            diagramData.flows.forEach((flow, idx) => {
                if (!nodeMap.has(flow.source)) {
                    nodeMap.set(flow.source, { name: flow.source, sourceLinks: [], targetLinks: [], value: 0, depth: 0 });
                }
                if (!nodeMap.has(flow.target)) {
                    nodeMap.set(flow.target, { name: flow.target, sourceLinks: [], targetLinks: [], value: 0, depth: 0 });
                }
                const link = {
                    source: nodeMap.get(flow.source),
                    target: nodeMap.get(flow.target),
                    value: flow.value,
                    color: flow.color,
                    index: idx
                };
                links.push(link);
                nodeMap.get(flow.source).sourceLinks.push(link);
                nodeMap.get(flow.target).targetLinks.push(link);
            });

            const nodes = Array.from(nodeMap.values());

            // Calculate node depths (columns)
            function computeDepths() {
                let remaining = [...nodes];
                let depth = 0;
                while (remaining.length > 0) {
                    const nextRemaining = [];
                    remaining.forEach(node => {
                        if (node.targetLinks.every(l => l.source.depth < depth || l.source === node)) {
                            node.depth = depth;
                        } else {
                            nextRemaining.push(node);
                        }
                    });
                    if (nextRemaining.length === remaining.length) {
                        nextRemaining.forEach(n => n.depth = depth);
                        break;
                    }
                    remaining = nextRemaining;
                    depth++;
                }
            }
            computeDepths();

            // Group by depth
            const maxDepth = Math.max(...nodes.map(n => n.depth));
            const columns = Array.from({ length: maxDepth + 1 }, () => []);
            nodes.forEach(node => columns[node.depth].push(node));

            // Calculate x positions
            const xScale = maxDepth > 0 ? innerWidth / maxDepth : innerWidth;
            nodes.forEach(node => {
                node.x = margin.left + node.depth * xScale;
            });

            // Calculate node values
            nodes.forEach(node => {
                const outgoing = node.sourceLinks.reduce((sum, l) => sum + l.value, 0);
                const incoming = node.targetLinks.reduce((sum, l) => sum + l.value, 0);
                node.value = Math.max(outgoing, incoming);
            });

            // Calculate y positions
            const totalValueByColumn = columns.map(col => col.reduce((sum, n) => sum + n.value, 0));
            const maxColumnValue = Math.max(...totalValueByColumn);
            const valueScale = maxColumnValue > 0 ? (innerHeight - (Math.max(...columns.map(c => c.length)) - 1) * nodePadding) / maxColumnValue : 1;

            columns.forEach((column, colIdx) => {
                const totalHeight = column.reduce((sum, n) => sum + n.value * valueScale, 0) + (column.length - 1) * nodePadding;
                let y = margin.top + (innerHeight - totalHeight) / 2;
                column.forEach(node => {
                    const savedPos = diagramData.nodePositions[node.name];
                    if (savedPos && savedPos.y !== undefined) {
                        node.y = savedPos.y;
                    } else {
                        node.y = y;
                    }
                    node.height = Math.max(node.value * valueScale, 4);
                    y += node.height + nodePadding;
                });
            });

            // Calculate link positions
            nodes.forEach(node => {
                let y0 = node.y;
                node.sourceLinks.sort((a, b) => a.target.y - b.target.y).forEach(link => {
                    link.y0 = y0 + link.value * valueScale / 2;
                    y0 += link.value * valueScale;
                });

                let y1 = node.y;
                node.targetLinks.sort((a, b) => a.source.y - b.source.y).forEach(link => {
                    link.y1 = y1 + link.value * valueScale / 2;
                    y1 += link.value * valueScale;
                });
            });

            // Calculate link widths
            links.forEach(link => {
                link.width = link.value * valueScale;
            });

            return { nodes, links, width, height, nodeWidth, margin };
        }

        // Generate link path
        function linkPath(link, nodeWidth) {
            const x0 = link.source.x + nodeWidth;
            const x1 = link.target.x;
            const xi = (x0 + x1) / 2;
            const y0 = link.y0;
            const y1 = link.y1;
            const halfWidth = link.width / 2;

            return `
                M ${x0} ${y0 - halfWidth}
                C ${xi} ${y0 - halfWidth}, ${xi} ${y1 - halfWidth}, ${x1} ${y1 - halfWidth}
                L ${x1} ${y1 + halfWidth}
                C ${xi} ${y1 + halfWidth}, ${xi} ${y0 + halfWidth}, ${x0} ${y0 + halfWidth}
                Z
            `;
        }

        // Render diagram
        function renderDiagram() {
            if (diagramData.flows.length === 0) {
                document.getElementById('sankey-canvas').innerHTML = `
                    <text x="50%" y="50%" text-anchor="middle" fill="#7C9CBF" font-family="Inter" font-size="14">
                        Add flows to create a diagram
                    </text>
                `;
                document.getElementById('nodes-tbody').innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--color-cobalt);">No nodes yet</td></tr>';
                return;
            }

            const { nodes, links, width, height, nodeWidth, margin } = calculateLayout();
            const svg = document.getElementById('sankey-canvas');
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            // Determine text color based on background
            const isDark = isColorDark(diagramData.settings.backgroundColor);
            const textColor = isDark ? '#FFFFFF' : '#353535';

            let html = `<defs>
                <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                    <feDropShadow dx="0" dy="1" stdDeviation="2" flood-opacity="0.15"/>
                </filter>
            </defs>`;

            // Draw links
            html += '<g class="links">';
            links.forEach((link, idx) => {
                const isSelected = selectedFlowIndex === link.index;
                const flow = diagramData.flows[link.index];
                html += `<path 
                    class="sankey-link${isSelected ? ' selected' : ''}" 
                    d="${linkPath(link, nodeWidth)}" 
                    fill="${flow.color}"
                    data-index="${link.index}"
                    onclick="selectFlow(${link.index}, event)"
                >
                    <title>${flow.source}  ${flow.target}: ${flow.value}</title>
                </path>`;
            });
            html += '</g>';
            
            // Draw flow labels (values on flows)
            if (diagramData.settings.showFlowValues) {
                html += '<g class="flow-labels">';
                links.forEach(link => {
                    const x0 = link.source.x + nodeWidth;
                    const x1 = link.target.x;
                    const midX = (x0 + x1) / 2;
                    const midY = (link.y0 + link.y1) / 2;
                    // Only show label if flow is wide enough
                    if (link.width > 8) {
                        html += `<text x="${midX}" y="${midY}" 
                            text-anchor="middle" dominant-baseline="middle"
                            class="flow-label" fill="${textColor}"
                            style="font-size: 10px; font-weight: 500; pointer-events: none;">
                            ${link.value}
                        </text>`;
                    }
                });
                html += '</g>';
            }

            // Draw nodes
            html += '<g class="nodes">';
            nodes.forEach(node => {
                const isSource = isSourceNode(node.name);
                const textX = node.depth === 0 ? node.x - 8 : node.x + nodeWidth + 8;
                const textAnchor = node.depth === 0 ? 'end' : 'start';
                const nodeColor = getNodeColor(node.name);
                
                // Calculate in/out values for tooltip
                const inValue = node.targetLinks ? node.targetLinks.reduce((sum, l) => sum + l.value, 0) : 0;
                const outValue = node.sourceLinks ? node.sourceLinks.reduce((sum, l) => sum + l.value, 0) : 0;
                const tooltipText = isSource 
                    ? `${node.name}\\nOutput: ${outValue}`
                    : `${node.name}\\nInput: ${inValue}\\nOutput: ${outValue || ''}`;
                
                // Build label with optional value
                let labelText = node.name;
                if (diagramData.settings.showNodeValues) {
                    labelText += ` (${node.value})`;
                }
                
                html += `<g class="sankey-node" data-name="${node.name}" 
                    onmousedown="handleNodeMouseDown(event, '${node.name}')"
                    ontouchstart="handleNodeMouseDown(event, '${node.name}')"
                    oncontextmenu="showNodeMenu(event, '${node.name}')">
                    <rect x="${node.x}" y="${node.y}" width="${nodeWidth}" height="${node.height}" 
                        fill="${nodeColor}" rx="2" filter="url(#shadow)">
                        <title>${tooltipText}</title>
                    </rect>
                    <text x="${textX}" y="${node.y + node.height / 2}" 
                        text-anchor="${textAnchor}" dominant-baseline="middle" fill="${textColor}">
                        ${labelText}
                    </text>
                </g>`;
            });
            html += '</g>';

            svg.innerHTML = html;
            renderNodesTable(nodes);
        }

        // Node mouse handling - distinguish between click and drag
        let isDragging = false;
        let dragStartTime = 0;
        let dragStartPos = { x: 0, y: 0 };
        
        function handleNodeMouseDown(event, nodeName) {
            // Right click is handled by context menu
            if (event.button === 2) return;
            
            event.preventDefault();
            draggedNode = nodeName;
            isDragging = false;
            dragStartTime = Date.now();
            dragStartPos = { 
                x: event.touches ? event.touches[0].clientX : event.clientX,
                y: event.touches ? event.touches[0].clientY : event.clientY
            };
            
            const svg = document.getElementById('sankey-canvas');
            const pt = svg.createSVGPoint();
            pt.x = dragStartPos.x;
            pt.y = dragStartPos.y;
            const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
            
            const currentY = diagramData.nodePositions[nodeName]?.y || 0;
            dragOffset.y = svgP.y - currentY;

            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', drag);
            document.addEventListener('touchend', endDrag);
        }

        function drag(event) {
            if (!draggedNode) return;
            
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            
            // Check if we've moved enough to consider it a drag
            const dx = clientX - dragStartPos.x;
            const dy = clientY - dragStartPos.y;
            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                isDragging = true;
            }
            
            if (!isDragging) return;
            
            event.preventDefault();
            closeAllPopups();

            const svg = document.getElementById('sankey-canvas');
            const pt = svg.createSVGPoint();
            pt.x = clientX;
            pt.y = clientY;
            const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());

            const newY = Math.max(20, Math.min(diagramData.settings.height - 40, svgP.y - dragOffset.y));
            
            if (!diagramData.nodePositions[draggedNode]) {
                diagramData.nodePositions[draggedNode] = {};
            }
            diagramData.nodePositions[draggedNode].y = newY;

            renderDiagram();
        }

        function endDrag(event) {
            const nodeName = draggedNode;
            const wasDragging = isDragging;
            
            draggedNode = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('touchend', endDrag);
            
            // If it was a short click (not a drag), show the add flow modal
            if (!wasDragging && nodeName && Date.now() - dragStartTime < 300) {
                // Short click - open add flow modal with this node as source
                openAddFlowModal(nodeName, '');
            }
            
            isDragging = false;
        }

        // Toggle node values display
        function toggleNodeValues() {
            diagramData.settings.showNodeValues = document.getElementById('show-node-values').checked;
            renderDiagram();
        }
        
        // Toggle flow values display
        function toggleFlowValues() {
            diagramData.settings.showFlowValues = document.getElementById('show-flow-values').checked;
            renderDiagram();
        }
        
        // Close all popups
        function closeAllPopups() {
            document.getElementById('node-menu').classList.remove('active');
            document.getElementById('flow-popup').classList.remove('active');
            selectedFlowIndex = null;
            selectedNodeName = null;
        }
        
        // Flow popup - quick edit colors
        let selectedFlowPopupColor = null;
        
        function selectFlow(index, event) {
            if (event) {
                event.stopPropagation();
            }
            closeAllPopups();
            closeAllColorPickers();
            
            selectedFlowIndex = index;
            const flow = diagramData.flows[index];
            selectedFlowPopupColor = flow.color;
            
            const popup = document.getElementById('flow-popup');
            document.getElementById('flow-popup-title').textContent = `${flow.source}  ${flow.target}`;
            document.getElementById('flow-popup-value').value = flow.value;
            
            // Render quick color palette
            const colorsDiv = document.getElementById('flow-popup-colors');
            colorsDiv.innerHTML = defaultFlowColors.concat(['#364064', '#7C9CBF', '#000000']).map(color => {
                const isSelected = color.toUpperCase() === flow.color.toUpperCase();
                return `<div class="flow-popup-color${isSelected ? ' selected' : ''}" 
                    style="background: ${color}" 
                    data-color="${color}"
                    onclick="selectFlowPopupColor('${color}')"></div>`;
            }).join('');
            
            // Position popup near click
            if (event) {
                const x = Math.min(event.clientX, window.innerWidth - 280);
                const y = Math.min(event.clientY, window.innerHeight - 250);
                popup.style.left = x + 'px';
                popup.style.top = y + 'px';
            } else {
                popup.style.left = '50%';
                popup.style.top = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
            }
            
            popup.classList.add('active');
            renderDiagram();
        }
        
        function selectFlowPopupColor(color) {
            selectedFlowPopupColor = color;
            document.querySelectorAll('.flow-popup-color').forEach(el => {
                el.classList.toggle('selected', el.dataset.color === color);
            });
        }
        
        function saveFlowPopup() {
            if (selectedFlowIndex !== null) {
                const value = parseFloat(document.getElementById('flow-popup-value').value) || 1;
                diagramData.flows[selectedFlowIndex].value = value;
                diagramData.flows[selectedFlowIndex].color = selectedFlowPopupColor;
                closeFlowPopup();
                renderFlowsTable();
                renderDiagram();
                showToast('Flow updated', 'success');
            }
        }
        
        function closeFlowPopup() {
            document.getElementById('flow-popup').classList.remove('active');
            document.getElementById('flow-popup').style.transform = '';
            selectedFlowIndex = null;
            selectedFlowPopupColor = null;
            renderDiagram();
        }
        
        function deleteSelectedFlow() {
            if (selectedFlowIndex !== null) {
                deleteFlow(selectedFlowIndex);
                closeFlowPopup();
            }
        }
        
        // Node context menu
        let selectedNodeName = null;
        
        function showNodeMenu(event, nodeName) {
            event.preventDefault();
            event.stopPropagation();
            closeAllPopups();
            closeAllColorPickers();
            
            selectedNodeName = nodeName;
            const menu = document.getElementById('node-menu');
            document.getElementById('node-menu-title').textContent = nodeName;
            
            // Position menu
            const x = Math.min(event.clientX, window.innerWidth - 200);
            const y = Math.min(event.clientY, window.innerHeight - 180);
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            
            menu.classList.add('active');
        }
        
        function closeNodeMenu() {
            document.getElementById('node-menu').classList.remove('active');
            selectedNodeName = null;
        }
        
        function addFlowFromNode() {
            if (!selectedNodeName) return;
            closeNodeMenu();
            openAddFlowModal(selectedNodeName, '');
        }
        
        function addFlowToNode() {
            if (!selectedNodeName) return;
            closeNodeMenu();
            openAddFlowModal('', selectedNodeName);
        }
        
        function deleteNode() {
            if (!selectedNodeName) return;
            // Remove all flows involving this node
            diagramData.flows = diagramData.flows.filter(f => f.source !== selectedNodeName && f.target !== selectedNodeName);
            closeNodeMenu();
            renderFlowsTable();
            renderDiagram();
            showToast(`Node "${selectedNodeName}" deleted`, 'success');
        }
        
        // Add flow modal
        let newFlowColor = null;
        
        function openAddFlowModal(source, target) {
            document.getElementById('new-flow-source').value = source;
            document.getElementById('new-flow-target').value = target;
            document.getElementById('new-flow-value').value = 10;
            
            // Suggest color based on source
            newFlowColor = source ? getSuggestedFlowColor(source) : defaultFlowColors[0];
            
            // Render color picker
            const colorsDiv = document.getElementById('new-flow-colors');
            colorsDiv.innerHTML = generateColorPickerHTML(newFlowColor, true);
            colorsDiv.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.addEventListener('click', () => {
                    newFlowColor = swatch.dataset.color;
                    colorsDiv.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');
                });
            });
            
            document.getElementById('add-flow-title').textContent = source && target ? 'Edit Flow' : 'Add Flow';
            document.getElementById('overlay').classList.add('active');
            document.getElementById('flow-editor').classList.add('active');
        }
        
        function saveNewFlow() {
            const source = document.getElementById('new-flow-source').value.trim();
            const target = document.getElementById('new-flow-target').value.trim();
            const value = parseFloat(document.getElementById('new-flow-value').value) || 10;
            
            if (!source || !target) {
                showToast('Source and target are required', 'error');
                return;
            }
            
            if (source === target) {
                showToast('Source and target must be different', 'error');
                return;
            }
            
            diagramData.flows.push({
                source,
                target,
                value,
                color: newFlowColor || defaultFlowColors[0]
            });
            
            closeFlowEditor();
            renderFlowsTable();
            renderDiagram();
            showToast('Flow added', 'success');
        }
        
        function closeFlowEditor() {
            document.getElementById('overlay').classList.remove('active');
            document.getElementById('flow-editor').classList.remove('active');
            newFlowColor = null;
        }
        
        // Switch to nodes tab (legacy support)
        function switchToNodesTab() {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.querySelector('.tab[data-tab="nodes"]').classList.add('active');
            document.getElementById('tab-nodes').classList.add('active');
        }

        // Update settings
        function updateSettings() {
            diagramData.settings.nodeWidth = parseInt(document.getElementById('node-width').value) || 20;
            diagramData.settings.nodePadding = parseInt(document.getElementById('node-padding').value) || 40;
            diagramData.settings.width = parseInt(document.getElementById('diagram-width').value) || 900;
            diagramData.settings.height = parseInt(document.getElementById('diagram-height').value) || 500;
            renderDiagram();
        }

        // Zoom functions
        function zoomIn() {
            zoom = Math.min(zoom + 0.1, 2);
            applyZoom();
        }

        function zoomOut() {
            zoom = Math.max(zoom - 0.1, 0.5);
            applyZoom();
        }

        function resetZoom() {
            zoom = 1;
            applyZoom();
        }

        function applyZoom() {
            const svg = document.getElementById('sankey-canvas');
            svg.style.transform = `scale(${zoom})`;
            svg.style.transformOrigin = 'top left';
            document.getElementById('zoom-display').textContent = `${Math.round(zoom * 100)}%`;
        }

        // Reset layout
        function resetLayout() {
            diagramData.nodePositions = {};
            renderDiagram();
            showToast('Layout reset', 'success');
        }

        // Export to JSON
        function exportToJSON() {
            const dataStr = JSON.stringify(diagramData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sankey-diagram.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('JSON exported', 'success');
        }

        // Export SVG
        function exportSVG() {
            const svg = document.getElementById('sankey-canvas');
            const clone = svg.cloneNode(true);
            clone.style.transform = '';
            clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            
            // Add background rect
            const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            bgRect.setAttribute('width', '100%');
            bgRect.setAttribute('height', '100%');
            bgRect.setAttribute('fill', diagramData.settings.backgroundColor);
            clone.insertBefore(bgRect, clone.firstChild);
            
            // Add embedded styles
            const isDark = isColorDark(diagramData.settings.backgroundColor);
            const textColor = isDark ? '#FFFFFF' : '#353535';
            const style = document.createElement('style');
            style.textContent = `
                .sankey-node text { font-family: Inter, Arial, sans-serif; font-size: 12px; font-weight: 500; fill: ${textColor}; }
                .sankey-link { fill-opacity: 0.5; }
            `;
            clone.insertBefore(style, clone.firstChild);
            
            const svgStr = new XMLSerializer().serializeToString(clone);
            const blob = new Blob([svgStr], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sankey-diagram.svg';
            a.click();
            URL.revokeObjectURL(url);
            showToast('SVG exported', 'success');
        }

        // Toast notification
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toast-message');
            const icon = toast.querySelector('.material-icons-outlined');
            
            toastMessage.textContent = message;
            toast.className = `toast ${type}`;
            icon.textContent = type === 'success' ? 'check_circle' : 'error';
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Close overlay on click
        document.getElementById('overlay').addEventListener('click', closeFlowEditor);
    </script>
</body>
</html>
